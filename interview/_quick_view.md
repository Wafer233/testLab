# golang interview 60

 1.1 Go 程序的基本结构？

 1.2 Go 有哪些关键字？

 1.3 Go 有哪些数据类型？

 1.4 Go 方法与函数的区别？

 1.5 Go 方法值接收者和指针接收者的区别?

 1.6 Go 函数返回局部变量的指针是否安全?

 1.7 Go 函数参数传递到底是值传递还是引用传递？


 1.8 Go defer关键字的实现原理？

 1.9 Go 内置函数make和new的区别？


 2.1 Go slice的底层实现原理?

 2.2 Go array和slice的区别？

 2.3 Go slice深拷贝和浅拷贝

 2.4 Go slice扩容机制？

 2.5 Go slice为什么不是线程安全的？


 3.1 Go map的底层实现原理？

 3.2 Go map遍历为什么是无序的？

 3.3 Go map为什么是非线程安全的？

 3.4 Go map如何查找？

 3.5 Go map冲突的解决方式？

 3.6.Go map 的负载因子为什么是 6.5？

 3.7 Go map如何扩容?


 3.8 Go map和sync.Map谁的性能好，为什么？


 4.1 Go channel的底层实现原理？

 4.2 Go channel有什么特点？

 4.3 Go channel有无缓冲的区别？


 4.4 Go channel为什么是线程安全的？

 4.5 Go channel如何控制goroutine并发执行顺序？

 4.6 Go channel共享内存有什么优劣势？
 
 4.7 Go channel发送和接收什么情况下会死锁？

 5.1 Go 互斥锁的实现原理？

 5.2 Go 互斥锁正常模式和饥饿模式的区别？

 5.3 Go 互斥锁允许自旋的条件？


 5.4 Go 读写锁的实现原理？

 5.5 Go 可重入锁如何实现？

 5.6 Go 原子操作有哪些？

 5.7 Go 原子操作和锁的区别？


 6.1 Go goroutine的底层实现原理？

 6.2 Go goroutine和线程的区别?

 6.3 Go goroutine泄露的场景?

 6.4 Go 如何查看正在执行的goroutine数量?

 6.5 Go 如何控制并发的goroutine数量?



 7.1 Go 线程实现模型？

 7.2 Go GMP和GM模型？

 7.3 Go 调度原理？

 7.4 Go work stealing 机制？

 7.5 Go hand off 机制？

 7.6 Go 抢占式调度？
 
 7.7 Go 如何查看运行时调度信息？


 8.1 Go 内存分配机制？

 8.2 Go 内存逃逸机制？

 8.3 Go 内存对齐机制？

 8.4 Go GC实现原理？

 8.5 Go GC如何调优？
 
 8.6 Go 如何查看GC信息？



 9.1 Go 常用的并发模型？

 9.2 Go 有哪些并发同步原语？

 9.3 Go WaitGroup实现原理？

 9.4 Go Cond实现原理？

 
 9.5 Go 有哪些方式安全读写共享变量？
 
 9.6 Go 如何排查数据竞争问题？
 